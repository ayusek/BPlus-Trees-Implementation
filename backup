#Assume that no duplicates are allowed , else check for duplicates while inserting

#My B-tree is such that a node that the smallest pointer in its left list

import time

'''
file structure
isroot : 
isleaf :
Parent :
left brother :
right brother :
'''   

import linecache
#linecache.getline('/etc/passwd', 4), 0 based count

Disc_Accesses = 0


output_file = open('queryOutput.txt','w')

#This would always remain open
with open ("bplustree.config", "r") as myfile:
	Disc_Accesses += 1
	parameter=myfile.read().replace('\n', '')

#number of entries is between n and 2*n now. 
n = int(parameter)
data_file =  open("tree/data", "ra")
Disc_Accesses += 1

#You call add_entry, next_line_no corresponds to its line number in the file

file_name_count = 0 
def get_new_name():
	global file_name_count 
	file_name_count += 1 
	return str(file_name_count)



#returns the file name in which the key may be present (Last Occourence Reported)
def get_node(key , node_file):
	
	node_file = str(node_file)
	if(node_file == None):
		return None	

	count = 0 
	switch = False 

	for line in open('tree/' + node_file , 'r'):
		line = line.replace('\n' , '')
		#return its name if its a leaf node
		if(count == 1 and int(line) == 1):
			return node_file

		if (count <=  4):
			count = count + 1
		else :
			#Not - a leaf node
			if (switch ==  False):
				switch = True
				old_path = line
			else:
				switch = False
				if (float(key) < float(line)):
					
					
					return get_node(key , old_path)

	return get_node(key , old_path)


#Returns the line number in the data file for the last occourence
def get_lineno_in_data(key):
	global root
	contatining_file = get_node(key , root)

	if(contatining_file == None):
		return None

	count = 0 
	switch = False 
	flag = False
	actual_line = None

	for line in open('tree/' + contatining_file , 'r'):
		line = line.replace('\n' , '')

		#return its name if its a leaf node
		if(count == 1):
			assert(int(line) == 1)

		if (count <=  4):
			count = count + 1

		else :
			#Not - a leaf node
			if (switch ==  False):
				switch = True
				line_no = int(line)

			else:
				switch = False
				if not flag:
					if (float(key)  == float(line)):
						flag = True
						actual_line = line_no
				else:
					if (float(key)  == float(line)):
						actual_line = line_no			

	return actual_line



next_line_no = -1 
def Insert_into_store(data):
	global next_line_no
	data = data.replace('\n','') + '\n'
	data_file.write(data)
	next_line_no += 1
	data = data.replace('\n','')
	data_file.write(data + "\n")
	return next_line_no


def adjust_right(file , value):
	global Disc_Accesses
	lines = []
	if(file == 'None'):
		return True

	with open ('tree/' + file , 'r') as myfile:
		Disc_Accesses += 1
		for line in myfile:
			lines.append(line)

	lines[4] = value
	with open ('tree/' + file , 'w') as myfile:
		Disc_Accesses += 1
		for item in lines:
			myfile.write(item)

	return True


def change_parent(file , parent):
	lines = []
	global Disc_Accesses
	with open ('tree/' + file , 'r') as myfile:
		Disc_Accesses += 1
		for line in myfile:
			lines.append(line)

	lines[2] = parent 
	with open ('tree/' + file , 'w') as myfile:
		Disc_Accesses += 1
		for line in lines:
			myfile.write(line)


def notify_children(list , parent):
	switch = True
	for item in list:
		if switch:
			change_parent(item.replace('\n','') , parent + '\n')
			switch = False
		else:
			switch = True

def Insert_into_node(node_name , pointer , key_value):
	node_name = str(node_name)
	pointer = str(pointer)
	key_value = str(key_value)
	lines = []
	global Disc_Accesses

	with open ('tree/' + node_name , 'r') as myfile:
		Disc_Accesses += 1
		for line in myfile:
			lines.append(line)

		#lines has the data for this file
	num_entries = int((len(lines) - 5)/2)


	if(num_entries < n ):
		#Insertable 

		if(len(lines) - 5 == 1):
			i = len(lines)
			lines = lines[0:i-1] + [pointer + '\n' , key_value + '\n' ] + [lines[i-1]]
			
		else:
			Switch = False
					#Insertable
			for i in range(5, len(lines)):

				if(Switch == False):
					Switch = True

				else:
					Switch = False

					if(float(key_value) < float(lines[i])):
						#To be Inserted
						
						lines = lines[0:i-1] + [pointer + '\n' , key_value + '\n' ]+ lines[i-1:]
						break
			else:
				i = len(lines)
				if(lines[i-1] == 'None\n'):
					lines = lines[0:i] + [pointer + '\n' , key_value + '\n' ]
				else:
					
					if(lines[1] == "1\n" ):

						lines = lines + [pointer + '\n' , key_value + '\n' ]
					else:
							lines = lines[0:i-1]   + [pointer + '\n' , key_value + '\n' ]+ lines[i-1 : ]
				

		with open ('tree/' + node_name , 'w') as myfile :
			Disc_Accesses += 1
			for item in lines:				
				myfile.write(item)
		return True

	else:
		
		#Non-Insertable
		#Form two out of them here and then carry them forward
		Switch = False
		for i in range(5, len(lines)):
			if(Switch == False):
				Switch = True

			else:
				Switch = False

				if(float(key_value) < float(lines[i])):
					#To be Inserted
					
					lines = lines[0:i-1] + [pointer + '\n' , key_value + '\n' ]+ lines[i-1:]
					break
		else:
			if(Switch == True):
				#last one was a pointer
				i = len(lines)
				lines = lines[0:i-1] + [pointer + '\n' , key_value + '\n' ]+ [lines[i-1]]
			else:
				#last one was a key
				lines = lines + [pointer + '\n' , key_value + '\n' ]

		#Now, I need to split the lines
		if(int(lines[1].replace('\n' ,'')) == 1):
			#Leaf Node
			#Split lines accordingly and then link those files
			old_headers = lines[0:5]
			
			entries = len(lines) - 5
			assert(entries%2 == 0 )
			data = lines[5:]
			size = len(data)
			assert(size % 2 == 0 )
			end = int(size/4)*2
			first_half = data[0:end]
			second_half = data[end:]

			second_part = old_headers + second_half
			first_part = ['0\n' , '1\n' , lines[2] , second_part[3] , node_name + '\n'] + first_half

			new_file = get_new_name()

			second_part[3] = new_file + '\n'

			with open ('tree/' + node_name , 'w') as myfile :
				Disc_Accesses += 1
				for item in second_part:				
					myfile.write(item)


			with open ('tree/' + new_file , 'w') as myfile :
				Disc_Accesses += 1
				for item in first_part:				
					myfile.write(item)

			adjust_right(first_part[3].replace('\n' , '') , new_file + '\n')

			return Insert_into_node(lines[2].replace('\n','') , new_file , second_part[6].replace('\n','') )
				
		else:
			old_headers = lines[0:5]
			
			entries = len(lines) - 5
			data = lines[5:]
			size = len(data)
			end = int(size/4)*2
			
			first_half = data[0:end-1]
			second_half = data[end:]

			Parent = old_headers[2].replace('\n','')
			carry = data[end-1].replace('\n','')

			if(Parent == 'None' and old_headers[0] == '1\n'):
				#Root Node
				new_file1 = get_new_name()
				new_file2 = get_new_name()
				old_headers[2] = new_file2 + '\n'
				old_headers[0] = "0\n"
				second_part = old_headers + second_half
				first_part = old_headers + first_half

				with open ('tree/' + new_file1 , 'w') as myfile :
					Disc_Accesses += 1
					for item in first_part:				
						myfile.write(item)

				#No need to maintain siblings
				with open ('tree/' + node_name , 'w') as myfile :
					Disc_Accesses += 1
					for item in second_part:				
						myfile.write(item)
				

				root_data = ['1\n' , '0\n' , 'None\n' , 'None\n' , 'None\n' , new_file1 + '\n' , carry + '\n' , node_name + '\n' ]

				with open ('tree/' + new_file2 , 'w') as myfile :
					Disc_Accesses += 1
					for item in root_data:				
						myfile.write(item)

				global root 
				root = new_file2

				notify_children(first_half , new_file1) #Tell children about their new parent

				return True
			else:
			#old_headers have information of the parent as well here
				second_part = old_headers + second_half
				first_part = old_headers + first_half

				new_file = get_new_name()

				with open ('tree/' + new_file , 'w') as myfile :
					Disc_Accesses += 1
					for item in first_part:				
						myfile.write(item)

				#No need to maintain siblings
				with open ('tree/' + node_name , 'w') as myfile :
					Disc_Accesses += 1
					for item in second_part:				
						myfile.write(item)

				notify_children(first_half , new_file)
				return Insert_into_node(Parent , new_file , carry)

		assert(False)
		return False
			



#Insertion Mastermind
def Insert_into_tree(key  , lineno):
	key = str(key)
	lineno = str(lineno)
	leaf_node_to_insert = get_node(key , root)
	return Insert_into_node(leaf_node_to_insert , lineno , key)


#The Data format needs to be very strict
def Insert(data):
	key = data.split('\t')[0]
	return Insert_into_tree(key , Insert_into_store(data))


#Insert Basic Data First
def Insert_Basic():
	for line in open('assgn2_bplus_data.txt','r'):
		Insert(line)

def Initialize():
	global root 
	global Disc_Accesses
	root = get_new_name()
	single_leaf = get_new_name()
	#Initializing Root
	with open ('tree/' + root , 'w') as myfile:
		Disc_Accesses += 1
		myfile.write('1\n')
		myfile.write('0\n')
		myfile.write('None\n')
		myfile.write('None\n')
		myfile.write('None\n')
		myfile.write(single_leaf + '\n')

	with  open ('tree/' + single_leaf , 'w') as myfile:
		Disc_Accesses += 1
		myfile.write('0\n')
		myfile.write('1\n')
		myfile.write(root + '\n')
		myfile.write('None\n')
		
		myfile.write('None\n')

def query0(key , value):
	key = key.replace('\n','').replace(' ','')
	value = value.replace('\n' , '').replace(' ','')

	global Disc_Accesses
	global output_file
	Disc_Accesses = 0 
	start_time = time.clock()

	if (Insert(key + '\t' + value + '\n')):
		time_taken = str(time.clock() - start_time)
		output_file.write("Insertion Done in "+ time_taken  +" seconds with "+str(Disc_Accesses) + " Disc Accesses")
	else:
		output_file.write("Insertion Unsuccessful")

	return True

def search_all_in_file(end_node , key):
	global data_list
	data_list = []
	lines = []

	with open ('tree/' + end_node , 'r') as myfile:
		for line in myfile:
			lines.append(line.replace('\n',''))

	#lines is the list of lines in this file
	left_brother = lines[3].replace('\n' ,'')
	switch = True
	put = True


	for i in reversed(range(5,len(lines))):
		if switch:
			switch = False
			print float(key) , float(lines[i])
			if(float(key) == float(lines[i])):
				put = True
			else:
				put = False
		else:
			switch = True
			if put :
				print "appended" + lines[i] +  linecache.getline('tree/data' , int(lines[i]))
				data_list.append(linecache.getline('tree/data' , int(lines[i])))
		
	if put : return data_list + search_all_in_file(left_brother , key)
	else : return data_list

def query1(key):
	key = str(key).replace('\n','').replace(' ','')
	#Searching this key
	global root
	data_list = search_all_in_file(get_node(key,root) , key) #Returns the node with the last occourence of the key
	return data_list



def query(file):
	with open (file , 'r') as myfile:
		for line in myfile :
			words = line.split('\t')
			if(words[0] == '0' ):
				query0(words[1] , words[2])
			elif(words[0] == '1'):
				query1(words[1])
			'''
			elif(words[0] == '1'):

			else:
				assert(False)
			'''
	return True

start_time = time.clock() 

Initialize()  #Initializes the B-Tree Structure..

'''
Insert_Basic()
or

root = 69
query('querysample.txt')

'''

for j in range(1,6):
	for i in range(1,100):
		print i  
		Insert(str(i) + '\t' + str(100*j + i )+ '\n')

print query1(10)

print time.clock() - start_time,"--seconds taken to do Basic Insertions"
print "Number of Disc Accesses:",Disc_Accesses 
print "Root node is:" , root

'''
for j in range(1,6):
	for i in range(1,100):
		print i  
		Insert_into_tree(i,100*j + i )



print "+++++"
'''
'''
print(get_node(7,root))
print(get_lineno_in_data(7))
'''

'''
print "++++++++++++++"
for i in range(1,100):
	print(get_lineno_in_data(i))
print("root node is",root)
#Insert_Basic()
'''
data_file.close()
output_file.close()


